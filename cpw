#!/bin/bash

if [[ $EUID != 0 ]]; then
    exec sudo "$0" "$@"
fi

# Help string can be overwritten in the cpw script
help_string="
Usage: cpw {run|rm|rerun|edit|update|build|new|start|stop} <service>
   or: cpw {ls|edit|script}

    -ls: list services and check which of them have existing images
    -run: start a new service; will build or update images if necessary
    -rm: remove a service image
    -rerun: shortcut to rm then run
    -edit: edit existing service; give no argument to edit compose file
    -update: manually update service image
    -build: manually build service image
    -new: create new profile
    -start: start a container if '--rm' has been removed from run arguments
    -exec: execute command on running container (default: bash)
    -commit: commit an existing container into the new image for a service
    -stop: stop a running container
    -script: edit cpw script
"

source ./script init "$@"

check_image_existence () {
    if ! $(docker images | grep "^$1\s" -q); then
        echo "This image does not exist: $1"
        echo "Use one of these images or create/pull a new one:"
        docker images
        exit 1
    fi
}

check_service_existence () {
    if ! $(docker-compose "${COMPOSE_OPTS[@]}" config --services | \
           grep "^$1$" -q); then
        echo "This service does not exist: $1"
        echo "Use one of these services or create a new one:"
        docker-compose "${COMPOSE_OPTS[@]}" config --services
        exit 1
    fi
}

# Takes image ID as argument, returns image names
get_children () {
    children=()

    # Get the list of local images associated with compose services
    images=$(comm -12 \
        <(docker images --format "{{.Repository}}" | sort) \
        <(docker-compose "${COMPOSE_OPTS[@]}" config --services | sort))

    # Get a list of images that are children of the input service
    for image in $images; do
        if $(docker history $image | grep "$1" -q); then
            children+=($image)
        fi
    done

    children=("${children[@]:1}")
}

# Takes a service name as argument
remove_containers () {
    containers=$(docker ps -aqf "name=cpw_$2")

    if [[ -n "$containers" ]]; then
        echo "These containers are based on $2:"
        ls_string="ID;CREATED AT;STATUS\n"

        # Format a list of containers based on input service
        for container in $containers; do
            container_status=$(docker ps -a \
                --format "{{.ID}};{{.CreatedAt}};{{.Status}}" \
                -f id="$container")
            ls_string="$ls_string$container_status\n"
        done

        echo -e "$ls_string" | column -t -s ";"
        echo
        echo "They will need to be removed before cpw can proceed"
        read -p "Do you want to remove them (y/N) " -n 1 -r
        echo

        if [[ "$REPLY" =~ ^[Yy]$ ]]; then
            source ./script stop "$@"
            for container in $containers; do
                docker rm "$container"
            done
        else
            exit 1
        fi
    fi
}

perform_build () {
    remove_containers "$@"
    
    old_image_ID=$(docker images -qf reference="$2")
    
    echo -e "\n\n################////////\nBuilding $2"
    source ./script build "$@"

    new_image_ID=$(docker images -qf reference="$2")
    
    # If the old image is not used anymore we remove it
    if [[ -n "$old_image_ID" ]] && \
       [[ "$new_image_ID" != "$old_image_ID" ]]; then

        get_children "$old_image_ID"
        if [[ ${#children[@]} -eq 0 ]]; then
            docker rmi "$old_image_ID"
        fi
    fi
}

# Recursively update parent images by rebuilding them
update_parent () {
    local repo_digests=$(docker inspect --format='{{.RepoDigests}}' "$2")
    local need_rebuild=false
    
    # We only look for parents if we hit a local image
    if [[ "$repo_digests" = '[]' ]]; then
        local parent=$(grep '^FROM' "$2"/Dockerfile | awk '{print $2}')
        local old_parent_ID=$(docker images -qf reference="$parent" | head -n 1)

        update_parent "$1" "$parent" "${@:3}"

        local new_parent_ID=$(docker images -qf reference="$parent" | head -n 1)

        # We want to rebuild the current image if its parent has been rebuilt
        if [[ "$new_parent_ID" != "$old_parent_ID" ]]; then
            need_rebuild=true
        fi
    fi
    
    image_age=$(docker images --format '{{.CreatedAt}}' "$2" | \
        awk '!($4="")' | head -n 1)
    image_age=$(date -d "$image_age" +%s)
    max_age=$(date -d "$PARENT_MAX_AGE days ago" +%s)
    
    # We check if the image is up to date
    if [[ "$image_age" -gt "$max_age" ]] && [[ "$need_rebuild" = false ]]; then
        return 0
    else
        trap 'exit 1' SIGINT
        if [[ "$repo_digests" = '[]' ]]; then
            # Local image, we build
            perform_build "$@"
        else
            # Remote image, we pull
            docker pull "$2"
        fi
    fi
}

perform_update () {
    check_service_existence "$2"
    check_image_existence "$2"

    image_age=$(docker images --format '{{.CreatedAt}}' "$2" | awk '!($4="")')
    image_age=$(date -d "$image_age" +%s)
    max_age=$(date -d "$MAX_AGE days ago" +%s)

    if [[ "$image_age" -lt "$max_age" ]]; then
        # Image is out of date, we first try to update its parents
        parent=$(grep '^FROM' "$2"/Dockerfile | awk '{print $2}')
        old_parent_ID=$(docker images -qf reference="$parent")

        update_parent "$1" "$parent" "${@:3}"

        new_parent_ID=$(docker images -qf reference="$parent")
        if [[ "$new_parent_ID" != "$old_parent_ID" ]]; then
            # If parent has been rebuilt, we rebuild the current image
            perform_build "$@"
        else
            # Otherwise, we simply update it
            echo -e "\n\n################////////\nUpdating $2..."
            source ./script update "$@"
        fi
    fi
}

do_ls () {
    # Minimize the number of times docker commands are run because they are slow
    services=$(docker-compose "${COMPOSE_OPTS[@]}" config --services | sort)
    images=$(docker images --format '{{.Repository}};{{.ID}};{{.CreatedSince}}')
    all_containers=$(docker ps -a)

    containers=""
    ls_string="SERVICES;IMAGES;CREATED;CONTAINERS;OF WHICH RUNNING\n"

    # Get a detailed list of compose services
    for service in $services; do
        image=$(echo "$images" | grep "^$service;" | awk -F ';' '{print $2'})

        if [[ -n "$image" ]]; then
            created=$(echo "$images" | grep "^$service;" | \
                awk -F ';' '{print $3}')
        else
            image='-'
            created='-'
        fi

        containers=$(echo "$all_containers" | grep "cpw_$service" | wc -l)
        running=$(echo "$all_containers" | grep "\sUp\s" | grep "cpw_$service" \
            | wc -l)
        ls_string="$ls_string$service;$image;$created;$containers;$running\n"
    done

    echo -e "$ls_string" | column -t -s ";"

    # Get a detailed list of containers created from compose services
    if [[ -n "$containers" ]]; then
        echo
        all_status=$(docker ps -a --format "{{.Image}};{{.ID}};{{.Status}}")
        ls_string="SERVICES;CONTAINERS;STATUS\n"

        for service in $services; do
            containers=$(echo "$all_containers" | grep "cpw_$service" | \
                awk '{print $1}')

            for container in $containers; do
                container_status=$(echo "$all_status" | grep "$container")
                ls_string="$ls_string$container_status\n"
            done
        done

        echo -e "$ls_string" | column -t -s ";"
    fi
}

do_build () {
    # If the image is remote, we pull
    if ! $(docker-compose "${COMPOSE_OPTS[@]}" config --services | \
           grep "^$2$" -q); then
        docker pull "$2"
        if [[ $? = 0 ]]; then
            return 0
        else
            echo "Could not pull image: $2"
            exit 1
        fi
    fi
    
    check_service_existence "$2"

    # We first need to know if the parent exists and is up to date
    parent=$(grep '^FROM' "$2"/Dockerfile | awk '{print $2}')

    if [[ -n $(docker images -qf reference="$parent") ]]; then
        # Parent image already exists, we update it
        update_parent "$1" "$parent" "${@:3}"
    else
        # Parent image does not exist, we build it
        do_build "$1" "$parent" "${@:3}"
    fi

    # Build the current image
    perform_build "$@"
}

do_run () {
    check_service_existence "$2"
    source ./script exec "$@"
    
    # We check if the image already exists, if not we need to build it
    if [[ -n $(docker images -qf reference="$2") ]]; then
        if [[ "$AUTO_UPDATE" = true ]]; then
            perform_update "$@"
        fi
    else
        do_build "$@"
    fi

    source ./script prerun "$@"
    docker-compose "${COMPOSE_OPTS[@]}" run "${RUN_ARGS[@]}" "$2"
    source ./script postrun "$@"
}

do_start () {
    check_service_existence "$2"
    source ./script exec "$@"
    source ./script start "$@"
}

do_exec () {
    check_service_existence "$2"
    source ./script exec "$@"
}

do_commit () {
    check_service_existence "$2"
    source ./script commit "$@"
}

do_stop () {
    check_service_existence "$2"
    source ./script stop "$@"
}

do_rm () {
    check_service_existence "$2"
    check_image_existence "$2"

    image_ID=$(docker images -qf reference="$2")

    get_children "$image_ID"
    if [[ ${#children[@]} -ne 0 ]]; then
        echo "The image you want to remove has the following children:"
        printf '%s\n' "${children[@]}"

        read -p "They will also be removed; continue? (y/N) " -n 1 -r
        echo

        if [[ "$REPLY" =~ ^[Yy]$ ]]; then
            for child in "${children[@]}"; do
                remove_containers "$1" "$child" "${@:3}"
                docker rmi "$child"
            done
        else
            exit 1
        fi
    fi

    remove_containers "$@"
    docker rmi "$2"
}

do_edit () {
    if [[ "$1" ]]; then
        check_service_existence "$1"

        "${EDITOR:-vi}" "$1"/Dockerfile
        echo "Run 'cpw build $1' if you want changes to take effect"
    else
        "${EDITOR:-vi}" docker-compose.yml
    fi
}

do_new () {
    if [[ "$1" ]]; then
        mkdir "$1"
        echo 'FROM ' > "$1"/Dockerfile
        "${EDITOR:-vi}" docker-compose.yml "$1"/Dockerfile
    else
        echo "You need to provide a service name"
    fi
}

case "$1" in
    ls)
        do_ls
        ;;

    build)
        do_build "$@"
        ;;

    run)
        do_run "$@"
        ;;

    start)
        do_start "$@"
        ;;

    exec)
        do_exec "$@"
        ;;

    commit)
        do_commit "$@"
        ;;

    stop)
        do_stop "$@"
        ;;

    rm)
        do_rm "$@"
        ;;

    rerun)
        do_rm "$@"
        do_run "$@"
        ;;

    edit)
        do_edit "$2"
        ;;

    new)
        do_new "$2"
        ;;

    update)
        check_service_existence "$2"
        check_image_existence "$2"
        source ./script update "$@"
        ;;

    script)
        "${EDITOR:-vi}" script
        ;;

    -h|--help|help)
        echo "$help_string"
        ;;

    *)
        source ./script "$@"
        exit 1
esac

source ./script exit "$@"
