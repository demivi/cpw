#!/bin/bash

if [ $EUID != 0 ]; then
    sudo "$0" "$@"
    exit $?
fi

# Help string can be overridden in the cpw script
help_string="
Usage: cpw {run|rm|rerun|edit|update|build|new|start|stop} <service>
   or: cpw {ls|edit|script}

    -ls: list services and check which of them have existing images
    -run: start a new service; will build or update images if necessary
    -rm: remove a service image
    -rerun: shortcut to rm then run
    -edit: edit existing service; give no argument to edit compose file
    -update: manually update service image
    -build: manually build service image
    -new: create new profile
    -start: start a container if '--rm' has been removed from run arguments
    -commit: commit an existing container into the new image for a service
    -stop: stop a running container
    -script: edit cpw script
"

source ./script init "$@"

check_image_existence () {
    if ! $(docker images | grep "^$1\s" -q); then
        echo "This image does not exist: $1"
        echo "Use one of these images or create/pull a new one:"
        docker images
        exit 1
    fi
}

check_service_existence () {
    if ! $(docker-compose config --services | grep "^$1$" -q); then
        echo "This service does not exist: $1"
        echo "Use one of these services or create a new one:"
        docker-compose config --services
        exit 1
    fi
}

do_ls () {
    services=$(docker-compose config --services)

    containers=""
    ls_string="SERVICES;IMAGES;CREATED;CONTAINERS;OF WHICH RUNNING\n"

    for service in $services; do
        image=$(docker images | grep "^$service\s" | awk '{print $3'})
        if [[ -n "$image" ]]; then
            created=$(docker images --format '{{.CreatedSince}}' "$service")
        else
            image='-'
            created='-'
        fi
        containers=$(docker ps -aqf ancestor="$image" | wc -l)
        running=$(docker ps -qf ancestor="$image" | wc -l)
        ls_string="$ls_string$service;$image;$created;$containers;$running\n"
    done
    echo -e "$ls_string" | column -t -s ";" -o "     "

    if [[ -n "$containers" ]]; then
        echo
        ls_string="SERVICES;CONTAINERS;STATUS\n"
        for service in $services; do
            containers=$(docker ps -aqf ancestor="$service")
            for container in $containers; do
                container_status=$(docker ps -a \
                    --format "{{.Image}};{{.ID}};{{.Status}}\n" \
                    -f id="$container")
                ls_string="$ls_string$container_status\n"
            done
        done
        echo -e "$ls_string" | column -t -s ";" -o "     "
    fi
}

get_children () {
    children=()

    for image in $(docker images -q); do
        if $(docker history $image | grep "$1" -q); then
            children+=($image)
        fi
    done

    children=("${children[@]:1}")
}

remove_containers () {
    containers=$(docker ps -aqf ancestor="$2")

    if [[ -n "$containers" ]]; then
        echo "These containers are based on $2:"
        for container in $containers; do
            docker ps -a | grep $container
        done
        echo "They will need to be removed before cpw can proceed"

        read -p "Do you want to remove them (y/N) " -n 1 -r
        echo

        if [[ "$REPLY" =~ ^[Yy]$ ]]; then
            for container in $containers; do
                source ./script stop "$@"
                docker rm "$container"
            done
        else
            exit 1
        fi
    fi
}

perform_build () {
    remove_containers "$@"
    
    old_image_ID=$(docker images -qf reference="$2")
    
    echo -e "\n\n################////////\nBuilding $2"
    source ./script build "$@"

    new_image_ID=$(docker images -qf reference="$2")
    
    # If the old image is not used anymore we remove it
    if [[ "$new_image_ID" != "$old_image_ID" ]]; then
        get_children "$old_image_ID"
        if [[ ${#children[@]} -eq 0 ]]; then
            docker rmi "$old_image_ID"
        fi
    fi
}

# Recursively update parent images by rebuilding them.
update_parent () {
    local repo_digests=$(docker inspect --format='{{.RepoDigests}}' "$2")
    
    # We only look for parents if we hit a local image
    if [[ "$repo_digests" = '[]' ]]; then
        parent=$(grep '^FROM' "$2"/Dockerfile | awk '{print $2}')
        update_parent "$1" "$parent" "${@:2}"
    fi
    
    image_age=$(docker images --format '{{.CreatedAt}}' "$2" | awk '!($4="")')
    image_age=$(date -d "$($image_date)" +%s)
    max_age=$(date -d "$PARENT_MAX_AGE days ago" +%s)
    
    # We check if the image is up to date
    if [[ "$image_age" -gt "$max_age" ]]; then
        return 0
    else
        trap 'exit 1' SIGINT
        if [[ "$repo_digests" = '[]' ]]; then
            # Local image, we build
            perform_build "$@"
        else
            # Remote image, we pull
            docker pull "$2"
        fi
    fi
    
    return 0
}

do_update () {
    check_service_existence "$2"
    check_image_existence "$2"

    image_age=$(docker images --format '{{.CreatedAt}}' "$2" | awk '!($4="")')
    image_age=$(date -d "$($image_date)" +%s)
    max_age=$(date -d "$MAX_AGE days ago" +%s)

    if [[ "$image_age" -lt "$max_age" ]]; then
        # Image is out of date, we first update its parents, then update it
        parent=$(grep '^FROM' "$2"/Dockerfile | awk '{print $2}')
        update_parent "$1" "$parent" "${@:2}"

        echo -e "\n\n################////////\nUpdating $2..."
        source ./script update "$@"
    fi
}

do_build () {
    # If the image is remote, we pull
    if ! $(docker-compose config --services | grep "^$2$" -q); then
        docker pull "$2"
        if [[ $? = 0 ]]; then
            return 0
        else
            echo "Could not pull image: $2"
            exit 1
        fi
    fi
    
    check_service_existence "$2"

    # We first need to know if the parent exists and is up to date
    parent=$(grep '^FROM' "$2"/Dockerfile | awk '{print $2}')

    if [[ -n $(docker images | grep "^$parent\s") ]]; then
        # Parent image already exists, we update it
        update_parent "$1" "$parent" "${@:2}"
    else
        # Parent image does not exist, we build it
        do_build "$1" "$parent" "${@:3}"
    fi

    # Build the current image
    perform_build "$@"
}

do_run () {
    check_service_existence "$2"
    
    running=$(docker-compose ps "$2" | grep Up | awk '{print $1}')

    if [ -n "$running" ]; then
        echo "$2 is already running, spawning a shell..."
        exec docker exec -ti "$running" bash
    else
        # We check if the image already exists
        if $(docker images | grep "^$2\s" -q); then
            if [[ $AUTO_UPDATE = true ]] ; then
                do_update "$@"
            fi
        else
            do_build "$1" "$parent" "${@:3}"
        fi
    fi

    source ./script prerun "$@"
    docker-compose run "${RUN_ARGS[@]}" "$2"
    source ./script postrun "$@"
}

do_start () {
    check_service_existence "$2"
    running=$(docker-compose ps "$2" | grep Up | awk '{print $1}')

    if [ -n "$running" ]; then
        echo "$2 is already running, spawning a shell..."
        exec docker exec -ti "$running" bash
    else
        source ./script start "$@"
    fi
}

do_commit () {
    check_service_existence "$2"
    source ./script commit "$@"
}

do_stop () {
    check_service_existence "$2"
    source ./script stop "$@"
}

do_rm () {
    check_service_existence "$2"
    check_image_existence "$2"
    remove_containers "$@"

    docker rmi "$2"
}

do_edit () {
    if [[ "$1" ]]; then
        check_service_existence "$1"

        "${EDITOR:-vi}" "$1"/Dockerfile
        echo "Run 'cpw build <service>' if you want changes to take effect"
    else
        "${EDITOR:-vi}" docker-compose.yml
    fi
}

do_new () {
    if [[ "$1" ]]; then
        mkdir "$1"
        echo 'FROM ' > "$1"/Dockerfile
        "${EDITOR:-vi}" docker-compose.yml "$1"/Dockerfile
    else
        echo "You need to provide a service name"
    fi
}

case "$1" in
    ls)
        do_ls
        ;;

    update)
        do_update "$@"
        ;;

    build)
        do_build "$@"
        ;;

    run)
        do_run "$@"
        ;;

    start)
        do_start "$@"
        ;;

    commit)
        do_commit "$@"
        ;;

    stop)
        do_stop "$@"
        ;;

    rm)
        do_rm "$@"
        ;;

    rerun)
        do_rm "$@"
        do_run "$@"
        ;;

    edit)
        do_edit "$2"
        ;;

    new)
        do_new "$2"
        ;;

    script)
        "${EDITOR:-vi}" script
        ;;

    -h|--help|help)
        echo "$help_string"
        ;;

    *)
        source ./script "$@"
        exit 1
esac
