#!/bin/bash

if [[ $EUID != 0 ]]; then
    exec sudo "$0" "$@"
fi

# Help string can be overwritten in the cpw script
HELP_STRING="
Usage: cpw {run|rm|rerun|edit|update|build|new|start|stop} <service>
   or: cpw {ls|edit|script}

    -ls: list services and check which of them have existing images
    -run: start a new service; will build or update images if necessary
    -rm: remove a service image
    -rerun: shortcut to rm then run
    -edit: edit existing service; give no argument to edit compose file
    -update: manually update service image
    -build: manually build service image
    -new: create new profile
    -start: start a container if '--rm' has been removed from run arguments
    -exec: execute command on running container (default: bash)
    -commit: commit an existing container into the new image for a service
    -stop: stop a running container
    -script: edit cpw script
"

IMAGE_ID_FILE='image_IDs'

source ./script init "$@"

check_image_existence () {
    if ! $(docker images | grep "^$1\s" -q); then
        echo "This image does not exist: $1"
        echo "Use one of these images or create/pull a new one:"
        docker images
        exit 1
    fi
}

check_service_existence () {
    if ! $(docker-compose "${COMPOSE_OPTS[@]}" config --services | \
           grep "^$1$" -q); then
        echo "This service does not exist: $1"
        echo "Use one of these services or create a new one:"
        docker-compose "${COMPOSE_OPTS[@]}" config --services
        exit 1
    fi
}

# Takes image name as first argument, image ID as second, returns image names
get_children () {
    children=()

    # Get a list of local images associated with compose services
    images=$(comm -12 \
        <(docker images --format "{{.Repository}}" | sort) \
        <(docker-compose "${COMPOSE_OPTS[@]}" config --services | sort))

    # Get a list of images that are children of the input service
    for image in $images; do
        if [[ $image != "$1" ]]; then
            if $(docker history $image | grep "$2" -q); then
                children+=($image)
            fi
        else
            if $(docker history -q $image | tail -n +2 | grep "$2" -q); then
                children+=($image)
            fi
        fi
    done
}

# Takes a service name as argument
remove_containers () {
    containers=$(docker ps -aqf "name=cpw_$2")

    if [[ -n "$containers" ]]; then
        echo "These containers are based on $2:"
        ls_string="ID;CREATED AT;STATUS\n"

        # Format a list of containers based on input service
        for container in $containers; do
            container_status=$(docker ps -a \
                --format "{{.ID}};{{.CreatedAt}};{{.Status}}" \
                -f id="$container")
            ls_string="$ls_string$container_status\n"
        done

        echo -e "$ls_string" | column -t -s ";"
        echo
        echo "They will need to be removed before cpw can proceed"
        read -p "Do you want to remove them (y/N) " -n 1 -r
        echo

        if [[ "$REPLY" =~ ^[Yy]$ ]]; then
            source ./script stop "$@"
            for container in $containers; do
                docker rm "$container"
            done
        else
            exit 1
        fi
    fi
}

# Takes image name as first argument, image ID as second
store_image_ID () {
    if $(grep -sq "last_build_of_$1" IMAGE_ID_FILE); then
        sed -i "s/.*last_build_of_$1/$2;last_build_of_$1/" IMAGE_ID_FILE
    else
        echo "$2;last_build_of_$1" > IMAGE_ID_FILE
    fi

    parent=$(grep '^FROM' "$1"/Dockerfile | awk '{print $2}')
    parent_ID=$(docker images -qf reference="$parent")

    if $(grep -sq "parent_of_$1" IMAGE_ID_FILE); then
        sed -i "s/.*parent_of_$1/$parent_ID;parent_of_$1/" IMAGE_ID_FILE
    else
        echo "$parent_ID;parent_of_$1" > IMAGE_ID_FILE
    fi
}

perform_build () {
    remove_containers "$@"
    
    old_image_ID=$(docker images -qf reference="$2")
    
    echo -e "\n\n################////////\nBuilding $2"
    source ./script build "$@"

    new_image_ID=$(docker images -qf reference="$2")
    
    # If the old image is not used anymore we remove it
    if [[ -n "$old_image_ID" ]] && \
       [[ "$new_image_ID" != "$old_image_ID" ]]; then

        get_children "$2" "$old_image_ID"
        if [[ ${#children[@]} -eq 0 ]]; then
            docker rmi "$old_image_ID"
        fi
    fi

    # We store image IDs for future use
    store_image_ID "$2" "$new_image_ID"
}

# Recursively build or pull images by going from the top parent
recursive_build () {
    local repo_digests=$(docker inspect --format='{{.RepoDigests}}' "$2")
    local build_needed=false
    
    # We only look for a parent if we hit a local image
    if [[ "$repo_digests" = '[]' ]]; then
        local parent=$(grep '^FROM' "$2"/Dockerfile | awk '{print $2}')
        local old_parent_ID=$(docker images -qf reference="$parent" | head -n 1)

        recursive_build "$1" "$parent" "${@:3}"

        new_parent_ID=$(docker images -qf reference="$parent" | head -n 1)
        stored_parent_ID=$(grep "parent_of_$2" IMAGE_ID_FILE | cut -d ";" -f1)

        # We want to build the current image if its parent has been rebuilt
        if [[ "$new_parent_ID" != "$old_parent_ID" ]]; then
            build_needed=true
        # We also want to build if the parent has a more recent build
        elif [[ "$stored_parent_ID" != "$old_parent_ID" ]]; then
            build_needed=true
        fi
    fi
    
    # We make sure the current image exists before trying to get its age
    if $(docker images | grep "^$2\s" -q); then
        stored_ID=$(grep "parent_of_$2" IMAGE_ID_FILE | cut -d ";" -f1)
        last_build=$(docker images --format '{{.CreatedAt}}' "$stored_ID" | \
                     awk '!($4="")' | head -n 1)
        last_build=$(date -d "$last_build" +%s)
        max_build_age=$(date -d "$REBUILD_DAYS days ago" +%s)

        # If the image is too old it needs to be rebuilt
        if [[ "$last_build" -lt "$max_build_age" ]]; then
            build_needed=true
        fi
    else
        # If the image does not exist it needs to be built
        build_needed=true
    fi

    # We build or pull the image if any of the previous checks passed
    if [[ "$build_needed" = true ]]; then
        trap 'exit 1' SIGINT
        if [[ "$repo_digests" = '[]' ]]; then
            # Local image, we build
            perform_build "$@"
        else
            # Remote image, we pull
            docker pull "$2"
            if [[ $? != 0 ]]; then
                echo "Could not pull image: $2"
                exit 1
            fi
        fi
    fi
}

update_check () {
    check_service_existence "$2"
    check_image_existence "$2"

    # We get a timestamp of the last build for this image
    stored_ID=$(grep "parent_of_$2" IMAGE_ID_FILE | cut -d ";" -f1)
    last_build=$(docker images --format '{{.CreatedAt}}' "$stored_ID" | \
                 awk '!($4="")' | head -n 1)
    last_build=$(date -d "$last_build" +%s)
    max_build_age=$(date -d "$REBUILD_DAYS days ago" +%s)

    # We check if the image needs to be rebuilt
    if [[ "$last_build" -lt "$max_build_age" ]]; then
        recursive_build "$@"
    else
        # If it does not, we check if it needs an update
        image_age=$(docker images --format '{{.CreatedAt}}' "$2" | \
                    awk '!($4="")')
        image_age=$(date -d "$image_age" +%s)
        max_age=$(date -d "$UPDATE_DAYS days ago" +%s)

        if [[ "$image_age" -lt "$max_age" ]]; then
            echo -e "\n\n################////////\nUpdating $2..."
            source ./script update "$@"
        fi
    fi
}

do_ls () {
    # Minimize the number of times docker commands are run because they are slow
    services=$(docker-compose "${COMPOSE_OPTS[@]}" config --services | sort)
    images=$(docker images --format '{{.Repository}};{{.ID}};{{.CreatedSince}}')
    all_containers=$(docker ps -a)

    containers=""
    ls_string="SERVICES;IMAGES;CREATED;CONTAINERS;OF WHICH RUNNING\n"

    # Get a detailed list of compose services
    for service in $services; do
        image=$(echo "$images" | grep "^$service;" | awk -F ';' '{print $2'})

        if [[ -n "$image" ]]; then
            created=$(echo "$images" | grep "^$service;" | \
                awk -F ';' '{print $3}')
        else
            image='-'
            created='-'
        fi

        containers=$(echo "$all_containers" | grep "cpw_$service" | wc -l)
        running=$(echo "$all_containers" | grep "\sUp\s" | grep "cpw_$service" \
            | wc -l)
        ls_string="$ls_string$service;$image;$created;$containers;$running\n"
    done

    echo -e "$ls_string" | column -t -s ";"

    # Get a detailed list of containers created from compose services
    if [[ -n "$containers" ]]; then
        echo
        all_status=$(docker ps -a --format "{{.Image}};{{.ID}};{{.Status}}")
        ls_string="SERVICES;CONTAINERS;STATUS\n"

        for service in $services; do
            containers=$(echo "$all_containers" | grep "cpw_$service" | \
                awk '{print $1}')

            for container in $containers; do
                container_status=$(echo "$all_status" | grep "$container")
                ls_string="$ls_string$container_status\n"
            done
        done

        echo -e "$ls_string" | column -t -s ";"
    fi
}

do_run () {
    check_service_existence "$2"
    source ./script exec "$@"
    
    # We check if the image already exists, if not we need to build it
    if [[ -n $(docker images -qf reference="$2") ]]; then
        if [[ "$AUTO_UPDATE" = true ]]; then
            update_check "$@"
        fi
    else
        recursive_build "$@"
    fi

    source ./script prerun "$@"
    docker-compose "${COMPOSE_OPTS[@]}" run "${RUN_ARGS[@]}" "$2"
    source ./script postrun "$@"
}

do_start () {
    check_service_existence "$2"
    source ./script exec "$@"
    source ./script start "$@"
}

do_exec () {
    check_service_existence "$2"
    source ./script exec "$@"
}

do_commit () {
    check_service_existence "$2"
    source ./script commit "$@"
}

do_stop () {
    check_service_existence "$2"
    source ./script stop "$@"
}

do_rm () {
    check_service_existence "$2"
    check_image_existence "$2"

    image_ID=$(docker images -qf reference="$2")

    get_children "$2" "$image_ID"
    if [[ ${#children[@]} -ne 0 ]]; then
        echo "The image you want to remove has the following children:"
        printf '%s\n' "${children[@]}"

        read -p "They will also be removed; continue? (y/N) " -n 1 -r
        echo

        if [[ "$REPLY" =~ ^[Yy]$ ]]; then
            for child in "${children[@]}"; do
                remove_containers "$1" "$child" "${@:3}"
                docker rmi "$child"
            done
        else
            exit 1
        fi
    fi

    remove_containers "$@"
    docker rmi "$2"
}

do_edit () {
    if [[ "$1" ]]; then
        check_service_existence "$1"

        "${EDITOR:-vi}" "$1"/Dockerfile
        echo "Run 'cpw build $1' if you want changes to take effect"
    else
        "${EDITOR:-vi}" docker-compose.yml
    fi
}

do_new () {
    if [[ "$1" ]]; then
        mkdir "$1"
        echo 'FROM ' > "$1"/Dockerfile
        "${EDITOR:-vi}" docker-compose.yml "$1"/Dockerfile
    else
        echo "You need to provide a service name"
    fi
}

case "$1" in
    ls)
        do_ls
        ;;

    build)
        recursive_build "$@"
        ;;

    run)
        do_run "$@"
        ;;

    start)
        do_start "$@"
        ;;

    exec)
        do_exec "$@"
        ;;

    commit)
        do_commit "$@"
        ;;

    stop)
        do_stop "$@"
        ;;

    rm)
        do_rm "$@"
        ;;

    rerun)
        do_rm "$@"
        do_run "$@"
        ;;

    edit)
        do_edit "$2"
        ;;

    new)
        do_new "$2"
        ;;

    update)
        check_service_existence "$2"
        check_image_existence "$2"
        source ./script update "$@"
        ;;

    script)
        "${EDITOR:-vi}" script
        ;;

    -h|--help|help)
        echo "$HELP_STRING"
        ;;

    *)
        source ./script "$@"
        exit 1
esac

source ./script exit "$@"
